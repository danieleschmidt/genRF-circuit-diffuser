#!/usr/bin/env python3
"""
Generation 1: MAKE IT WORK - Basic GenRF functionality demonstration
Autonomous SDLC execution without external dependencies
"""

import json
import time
import random
import math
from pathlib import Path

class DesignSpec:
    """Basic design specification for RF circuits"""
    
    def __init__(self, circuit_type='LNA', frequency=2.4e9, gain_min=15, 
                 nf_max=1.5, power_max=10e-3, supply_voltage=1.2,
                 temperature=27, input_impedance=50, output_impedance=50):
        self.circuit_type = circuit_type
        self.frequency = frequency
        self.gain_min = gain_min
        self.nf_max = nf_max
        self.power_max = power_max
        self.supply_voltage = supply_voltage
        self.temperature = temperature
        self.input_impedance = input_impedance
        self.output_impedance = output_impedance

class CircuitResult:
    """Result of circuit generation with performance metrics"""
    
    def __init__(self, netlist, parameters, performance, topology, 
                 technology, generation_time, spice_valid=True):
        self.netlist = netlist
        self.parameters = parameters
        self.performance = performance
        self.topology = topology
        self.technology = technology
        self.generation_time = generation_time
        self.spice_valid = spice_valid
    
    @property
    def gain(self):
        return self.performance.get('gain_db', 0.0)
    
    @property
    def nf(self):
        return self.performance.get('noise_figure_db', float('inf'))
    
    @property
    def power(self):
        return self.performance.get('power_w', 0.0)
    
    def export_skill(self, filepath):
        """Export to Cadence SKILL format"""
        with open(filepath, 'w') as f:
            f.write(f"; SKILL Export - {self.topology}\n")
            f.write(f"; Generated by GenRF CircuitDiffuser\n")
            f.write(f"; Performance: Gain={self.gain:.1f}dB, NF={self.nf:.2f}dB\n\n")
            f.write(self.netlist)

class CircuitDiffuser:
    """Basic AI-powered RF circuit generator - Generation 1 Implementation"""
    
    def __init__(self, checkpoint=None, spice_engine="analytical", 
                 technology="generic", verbose=True):
        self.checkpoint = checkpoint
        self.spice_engine = spice_engine
        self.technology = technology
        self.verbose = verbose
        
        if verbose:
            print("ðŸš€ CircuitDiffuser Generation 1: MAKE IT WORK")
            print(f"   Technology: {technology}")
            print(f"   SPICE Engine: {spice_engine}")
            print("   âœ… Initialization complete")
    
    def generate(self, spec, n_candidates=10, optimization_steps=20, spice_validation=False):
        """Generate optimized RF circuit"""
        
        start_time = time.time()
        
        if self.verbose:
            print(f"\nðŸ”¬ Generating {spec.circuit_type} circuit")
            print(f"   Target: {spec.frequency/1e9:.2f}GHz, {spec.gain_min}dB gain, {spec.nf_max}dB NF")
        
        # Step 1: Generate topology using simplified AI model
        topology = self._generate_topology(spec)
        
        # Step 2: Optimize parameters using simplified optimization
        parameters = self._optimize_parameters(topology, spec, optimization_steps)
        
        # Step 3: Create netlist
        netlist = self._create_netlist(topology, parameters, spec)
        
        # Step 4: Estimate performance analytically
        performance = self._estimate_performance(parameters, spec)
        
        generation_time = time.time() - start_time
        
        result = CircuitResult(
            netlist=netlist,
            parameters=parameters,
            performance=performance,
            topology=topology['name'],
            technology=self.technology,
            generation_time=generation_time,
            spice_valid=spice_validation
        )
        
        if self.verbose:
            print(f"   âœ… Generation complete ({generation_time:.2f}s)")
            print(f"   Performance: Gain={result.gain:.1f}dB, NF={result.nf:.2f}dB, Power={result.power*1000:.1f}mW")
        
        return result
    
    def _generate_topology(self, spec):
        """Generate circuit topology - simplified version"""
        
        # Simplified topology generation based on circuit type
        topologies = {
            'LNA': {
                'name': 'cascode_lna',
                'components': ['M1_main', 'M2_cascode', 'L_source', 'L_gate', 'L_drain', 'C_coupling', 'R_load'],
                'type': 'cascode'
            },
            'Mixer': {
                'name': 'gilbert_mixer',
                'components': ['M_rf1', 'M_rf2', 'M_lo1', 'M_lo2', 'M_tail', 'R_load1', 'R_load2'],
                'type': 'gilbert_cell'
            },
            'VCO': {
                'name': 'lc_vco',
                'components': ['M1', 'M2', 'L_tank', 'C_tank', 'C_var'],
                'type': 'cross_coupled'
            }
        }
        
        topology = topologies.get(spec.circuit_type, topologies['LNA'])
        
        # Add some randomization for diversity
        topology['variant'] = random.randint(1, 5)
        
        return topology
    
    def _optimize_parameters(self, topology, spec, steps):
        """Optimize circuit parameters - simplified Bayesian-like optimization"""
        
        # Start with reasonable default parameters based on circuit type
        if spec.circuit_type == 'LNA':
            parameters = {
                'W1': random.uniform(20e-6, 100e-6),  # Main transistor width
                'L1': random.uniform(50e-9, 500e-9),   # Main transistor length
                'W2': random.uniform(10e-6, 50e-6),    # Cascode width
                'L2': random.uniform(50e-9, 300e-9),   # Cascode length
                'Ls': random.uniform(1e-9, 10e-9),     # Source inductance
                'Lg': random.uniform(1e-9, 10e-9),     # Gate inductance
                'Ld': random.uniform(1e-9, 10e-9),     # Drain inductance
                'Ibias': random.uniform(1e-3, 10e-3),  # Bias current
                'Vbias': random.uniform(0.5, 1.0)      # Bias voltage
            }
        elif spec.circuit_type == 'Mixer':
            parameters = {
                'Wrf': random.uniform(30e-6, 80e-6),
                'Wlo': random.uniform(40e-6, 100e-6),
                'Wtail': random.uniform(50e-6, 150e-6),
                'RL': random.uniform(500, 2000),
                'Ibias': random.uniform(1e-3, 5e-3)
            }
        elif spec.circuit_type == 'VCO':
            parameters = {
                'W': random.uniform(50e-6, 200e-6),
                'L': random.uniform(50e-9, 200e-9),
                'Ltank': random.uniform(1e-9, 20e-9),
                'Ctank': random.uniform(0.5e-12, 5e-12),
                'Ibias': random.uniform(5e-3, 20e-3)
            }
        
        # Simple optimization loop - gradually improve parameters
        best_fom = 0
        best_params = parameters.copy()
        
        for step in range(steps):
            # Add some random variation
            test_params = parameters.copy()
            for key in test_params:
                variation = random.uniform(0.8, 1.2)
                test_params[key] = test_params[key] * variation
            
            # Evaluate figure of merit
            perf = self._estimate_performance(test_params, spec)
            fom = self._calculate_fom(perf, spec)
            
            if fom > best_fom:
                best_fom = fom
                best_params = test_params.copy()
                parameters = test_params.copy()  # Use for next iteration
        
        return best_params
    
    def _create_netlist(self, topology, parameters, spec):
        """Create SPICE netlist"""
        
        netlist = f"""* {topology['name']} - Generated by GenRF Generation 1
* Target: {spec.frequency/1e9:.2f}GHz, {spec.gain_min}dB gain, {spec.nf_max}dB NF

.param vdd={spec.supply_voltage}
.param temp={spec.temperature}

"""
        
        if spec.circuit_type == 'LNA':
            netlist += f"""* LNA Core Circuit
M1 n1 input source bulk nch W={parameters['W1']:.3e} L={parameters['L1']:.3e}
M2 output vbias n1 bulk nch W={parameters['W2']:.3e} L={parameters['L2']:.3e}

* Matching Networks
Ls input n2 {parameters['Ls']:.3e}
Lg n2 gate {parameters['Lg']:.3e}
Ld output n3 {parameters['Ld']:.3e}

* Biasing
Vbias vbias 0 DC {parameters['Vbias']:.3f}
Ibias source 0 DC {parameters['Ibias']:.3e}

* Supply
Vdd vdd 0 DC {spec.supply_voltage}
"""
        
        elif spec.circuit_type == 'Mixer':
            netlist += f"""* Gilbert Cell Mixer
M1 n1 rf_input tail bulk nch W={parameters['Wrf']:.3e} L=100n
M2 n2 rf_input_n tail bulk nch W={parameters['Wrf']:.3e} L=100n
M3 if_out lo_p n1 bulk nch W={parameters['Wlo']:.3e} L=100n
M4 if_out_n lo_n n1 bulk nch W={parameters['Wlo']:.3e} L=100n

Mtail tail vbias 0 bulk nch W={parameters['Wtail']:.3e} L=200n
RL1 if_out vdd {parameters['RL']:.1f}
RL2 if_out_n vdd {parameters['RL']:.1f}

Ibias vbias 0 DC {parameters['Ibias']:.3e}
Vdd vdd 0 DC {spec.supply_voltage}
"""
        
        elif spec.circuit_type == 'VCO':
            netlist += f"""* LC VCO
M1 outp outn tail bulk nch W={parameters['W']:.3e} L={parameters['L']:.3e}
M2 outn outp tail bulk nch W={parameters['W']:.3e} L={parameters['L']:.3e}

L1 outp vdd {parameters['Ltank']:.3e}
L2 outn vdd {parameters['Ltank']:.3e}
C1 outp outn {parameters['Ctank']:.3e}

Ibias tail 0 DC {parameters['Ibias']:.3e}
Vdd vdd 0 DC {spec.supply_voltage}
"""
        
        netlist += "\n.model nch nmos level=1\n.end\n"
        
        return netlist
    
    def _estimate_performance(self, parameters, spec):
        """Analytical performance estimation"""
        
        if spec.circuit_type == 'LNA':
            # LNA performance estimation
            W1 = parameters.get('W1', 50e-6)
            Ibias = parameters.get('Ibias', 5e-3)
            
            # Simplified gm calculation
            gm = 2 * Ibias / 0.3  # Assuming Vov = 0.3V
            
            # Gain estimation
            gain_linear = gm * 1000  # Assuming 1k load
            gain_db = 20 * math.log10(max(gain_linear, 1e-3))
            
            # Noise figure (simplified)
            nf_db = 1.0 + 2.5 / gm + 0.1 * (W1 / 100e-9)
            
            # Power
            power_w = Ibias * spec.supply_voltage
            
            return {
                'gain_db': min(gain_db, 50.0),
                'noise_figure_db': max(nf_db, 0.8),
                'power_w': power_w,
                's11_db': -15.0,
                'bandwidth_hz': spec.frequency * 0.1
            }
        
        elif spec.circuit_type == 'Mixer':
            # Mixer performance estimation
            Ibias = parameters.get('Ibias', 2e-3)
            gm = 2 * Ibias / 0.3
            
            conversion_gain_db = 20 * math.log10((2 / math.pi) * gm * 1000)
            nf_db = 10 + 20 * math.log10(spec.frequency / 1e9)
            power_w = Ibias * spec.supply_voltage
            
            return {
                'gain_db': min(conversion_gain_db, 20.0),
                'noise_figure_db': max(nf_db, 8.0),
                'power_w': power_w,
                's11_db': -10.0,
                'bandwidth_hz': spec.frequency * 0.05
            }
        
        elif spec.circuit_type == 'VCO':
            # VCO performance estimation
            Ltank = parameters.get('Ltank', 5e-9)
            Ctank = parameters.get('Ctank', 1e-12)
            Ibias = parameters.get('Ibias', 10e-3)
            
            f_osc = 1 / (2 * math.pi * math.sqrt(Ltank * Ctank))
            phase_noise = -120 - 10 * math.log10(Ibias / 1e-3)
            power_w = Ibias * spec.supply_voltage
            
            return {
                'gain_db': 0.0,  # VCO doesn't have gain
                'noise_figure_db': float('inf'),
                'power_w': power_w,
                'frequency_hz': f_osc,
                'phase_noise_dbchz': phase_noise,
                'tuning_range_hz': f_osc * 0.1
            }
        
        # Generic fallback
        return {
            'gain_db': 15.0,
            'noise_figure_db': 3.0,
            'power_w': 0.005,
            's11_db': -10.0,
            'bandwidth_hz': spec.frequency * 0.1
        }
    
    def _calculate_fom(self, performance, spec):
        """Calculate figure of merit"""
        
        gain = performance.get('gain_db', 0)
        nf = performance.get('noise_figure_db', 100)
        power = performance.get('power_w', 1)
        
        # Check if specs are met
        gain_ok = gain >= spec.gain_min
        nf_ok = nf <= spec.nf_max
        power_ok = power <= spec.power_max
        
        if not (gain_ok and nf_ok and power_ok):
            return 0.0
        
        # Figure of merit calculation
        fom = gain / (power * 1000 * max(1.0, nf - 1.0))
        return fom

def demo_generation_1():
    """Demonstrate Generation 1 functionality"""
    
    print("=" * 60)
    print("ðŸš€ GenRF Generation 1: MAKE IT WORK - AUTONOMOUS EXECUTION")
    print("=" * 60)
    
    # Test different circuit types
    circuits = [
        ('LNA', 2.4e9, 15, 1.5, 10e-3),
        ('Mixer', 5.8e9, 8, 8.0, 15e-3),
        ('VCO', 10e9, 0, float('inf'), 20e-3)
    ]
    
    results = []
    diffuser = CircuitDiffuser(verbose=True)
    
    for circuit_type, freq, gain, nf, power in circuits:
        print(f"\nðŸ“¡ Generating {circuit_type} circuit...")
        
        spec = DesignSpec(
            circuit_type=circuit_type,
            frequency=freq,
            gain_min=gain,
            nf_max=nf,
            power_max=power
        )
        
        # Generate circuit
        result = diffuser.generate(spec, n_candidates=5, optimization_steps=10)
        
        # Save results
        results.append({
            'circuit_type': circuit_type,
            'frequency_ghz': freq / 1e9,
            'target_gain_db': gain,
            'target_nf_db': nf,
            'target_power_mw': power * 1000,
            'achieved_gain_db': result.gain,
            'achieved_nf_db': result.nf,
            'achieved_power_mw': result.power * 1000,
            'generation_time_s': result.generation_time,
            'topology': result.topology,
            'meets_specs': all([
                result.gain >= gain if gain > 0 else True,
                result.nf <= nf if nf < float('inf') else True,
                result.power <= power
            ])
        })
        
        # Export netlist
        netlist_file = Path(f"gen1_outputs/{circuit_type.lower()}_design.spice")
        netlist_file.parent.mkdir(exist_ok=True)
        with open(netlist_file, 'w') as f:
            f.write(result.netlist)
        
        # Export SKILL
        skill_file = Path(f"gen1_outputs/{circuit_type.lower()}_design.il")
        result.export_skill(skill_file)
    
    # Save comprehensive results
    summary_file = Path("gen1_outputs/generation_summary.json")
    with open(summary_file, 'w') as f:
        json.dump({
            'generation': 'Generation 1: MAKE IT WORK',
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'total_circuits': len(results),
            'success_rate': sum(1 for r in results if r['meets_specs']) / len(results),
            'avg_generation_time': sum(r['generation_time_s'] for r in results) / len(results),
            'results': results
        }, f, indent=2)
    
    print(f"\nâœ… Generation 1 Complete!")
    print(f"   Circuits generated: {len(results)}")
    print(f"   Success rate: {sum(1 for r in results if r['meets_specs'])}/{len(results)}")
    print(f"   Average time: {sum(r['generation_time_s'] for r in results)/len(results):.2f}s")
    print(f"   Outputs saved to: gen1_outputs/")
    
    return results

if __name__ == "__main__":
    demo_generation_1()