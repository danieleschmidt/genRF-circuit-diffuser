"""
Code export functionality for generated circuits.

This module provides exporters for various EDA tool formats including
Cadence SKILL, Verilog-A, Keysight ADS, and others.
"""

from pathlib import Path
from typing import Dict, List, Optional, Union, Any
import logging
from datetime import datetime
import json

logger = logging.getLogger(__name__)


class CodeExporter:
    """
    Multi-format code exporter for RF circuits.
    
    Exports generated circuits to various EDA tool formats for further
    design and simulation.
    """
    
    def __init__(self):
        """Initialize code exporter."""
        self.supported_formats = [
            'skill', 'verilog-a', 'ads', 'spice', 'spectre', 
            'matlab', 'python', 'json'
        ]
        
        logger.info("Initialized CodeExporter")
    
    def export_skill(self, circuit_result, filepath: Union[str, Path]) -> None:
        """
        Export circuit to Cadence SKILL format.
        
        Args:
            circuit_result: CircuitResult object with circuit data
            filepath: Output file path
        """
        filepath = Path(filepath)
        
        skill_code = self._generate_skill_code(circuit_result)
        
        with open(filepath, 'w') as f:
            f.write(skill_code)
        
        logger.info(f"Exported SKILL code to {filepath}")
    
    def export_verilog_a(self, circuit_result, filepath: Union[str, Path]) -> None:
        """
        Export circuit to Verilog-A format.
        
        Args:
            circuit_result: CircuitResult object with circuit data
            filepath: Output file path
        """
        filepath = Path(filepath)
        
        verilog_code = self._generate_verilog_a_code(circuit_result)
        
        with open(filepath, 'w') as f:
            f.write(verilog_code)
        
        logger.info(f"Exported Verilog-A code to {filepath}")
    
    def export_ads(self, circuit_result, filepath: Union[str, Path]) -> None:
        """
        Export circuit to Keysight ADS format.
        
        Args:
            circuit_result: CircuitResult object with circuit data
            filepath: Output file path
        """
        filepath = Path(filepath)
        
        ads_code = self._generate_ads_code(circuit_result)
        
        with open(filepath, 'w') as f:
            f.write(ads_code)
        
        logger.info(f"Exported ADS netlist to {filepath}")
    
    def export_spice(self, circuit_result, filepath: Union[str, Path]) -> None:
        """
        Export circuit to SPICE format.
        
        Args:
            circuit_result: CircuitResult object with circuit data
            filepath: Output file path
        """
        filepath = Path(filepath)
        
        with open(filepath, 'w') as f:
            f.write(circuit_result.netlist)
        
        logger.info(f"Exported SPICE netlist to {filepath}")
    
    def export_json(self, circuit_result, filepath: Union[str, Path]) -> None:
        """
        Export circuit data to JSON format.
        
        Args:
            circuit_result: CircuitResult object with circuit data
            filepath: Output file path
        """
        filepath = Path(filepath)
        
        circuit_data = {
            'circuit_info': {
                'topology': circuit_result.topology,
                'technology': circuit_result.technology,
                'generation_time': circuit_result.generation_time,
                'spice_valid': circuit_result.spice_valid
            },
            'parameters': circuit_result.parameters,
            'performance': circuit_result.performance,
            'netlist': circuit_result.netlist,
            'export_timestamp': datetime.now().isoformat()
        }
        
        with open(filepath, 'w') as f:
            json.dump(circuit_data, f, indent=2)
        
        logger.info(f"Exported circuit data to JSON: {filepath}")
    
    def _generate_skill_code(self, circuit_result) -> str:
        """Generate Cadence SKILL code."""
        lines = [
            "; Generated by GenRF CircuitDiffuser",
            f"; Circuit: {circuit_result.topology}",
            f"; Technology: {circuit_result.technology}",
            f"; Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            f"procedure( create_{circuit_result.topology.lower()}_schematic()",
            "",
            "  ; Create schematic view",
            f"  let( (cv lib cell view)",
            f"    lib = ddGetObj(\"RF_DESIGNS\")",
            f"    cell = ddCreateCellView(lib \"{circuit_result.topology}\" \"schematic\")",
            f"    cv = cell~>schematic",
            "",
            "    ; Set schematic properties",
            f"    dbCreateRect(cv list(\"drawing\" \"boundary\") list(0:0 100:100))",
            ""
        ]
        
        # Add component instantiation
        component_id = 0
        for param_name, param_value in circuit_result.parameters.items():
            if '_w' in param_name:
                # Transistor width
                comp_name = param_name.replace('_w', '')
                length_param = param_name.replace('_w', '_l')
                length = circuit_result.parameters.get(length_param, 100e-9)
                
                lines.extend([
                    f"    ; Add transistor {comp_name}",
                    f"    dbCreateInst(cv \"analogLib\" \"nmos4\" \"{comp_name}\"",
                    f"      {component_id*20}:{component_id*20}",
                    f"      list(list(\"w\" \"float\" {param_value:.3e})",
                    f"           list(\"l\" \"float\" {length:.3e})))",
                    ""
                ])
                component_id += 1
            
            elif '_r' in param_name:
                # Resistor
                comp_name = param_name.replace('_r', '')
                lines.extend([
                    f"    ; Add resistor {comp_name}",
                    f"    dbCreateInst(cv \"analogLib\" \"res\" \"{comp_name}\"",
                    f"      {component_id*20}:{component_id*20}",
                    f"      list(list(\"r\" \"float\" {param_value:.3e})))",
                    ""
                ])
                component_id += 1
            
            elif '_c' in param_name:
                # Capacitor
                comp_name = param_name.replace('_c', '')
                lines.extend([
                    f"    ; Add capacitor {comp_name}",
                    f"    dbCreateInst(cv \"analogLib\" \"cap\" \"{comp_name}\"",
                    f"      {component_id*20}:{component_id*20}",
                    f"      list(list(\"c\" \"float\" {param_value:.3e})))",
                    ""
                ])
                component_id += 1
        
        lines.extend([
            "    ; Fit schematic to window",
            "    geZoomFit(cv)",
            "    ",
            "    ; Return cell view",
            "    cv",
            "  )",
            ")",
            "",
            f"; Call the procedure to create schematic",
            f"create_{circuit_result.topology.lower()}_schematic()"
        ])
        
        return '\n'.join(lines)
    
    def _generate_verilog_a_code(self, circuit_result) -> str:
        """Generate Verilog-A behavioral model code."""
        lines = [
            "// Generated by GenRF CircuitDiffuser",
            f"// Circuit: {circuit_result.topology}",
            f"// Technology: {circuit_result.technology}",
            f"// Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "`include \"constants.vams\"",
            "`include \"disciplines.vams\"",
            "",
            f"module {circuit_result.topology.lower()}_model(input_p, input_n, output_p, output_n, vdd, vss);",
            "",
            "  inout input_p, input_n, output_p, output_n, vdd, vss;",
            "  electrical input_p, input_n, output_p, output_n, vdd, vss;",
            "",
            "  // Model parameters",
        ]
        
        # Add parameters
        for param_name, param_value in circuit_result.parameters.items():
            lines.append(f"  parameter real {param_name} = {param_value:.3e};")
        
        lines.extend([
            "",
            "  // Performance metrics",
            f"  parameter real gain_db = {circuit_result.performance.get('gain_db', 0):.2f};",
            f"  parameter real nf_db = {circuit_result.performance.get('noise_figure_db', 3):.2f};",
            f"  parameter real power_w = {circuit_result.performance.get('power_w', 0.01):.3e};",
            "",
            "  // Behavioral model",
            "  analog begin",
            "    // Simplified behavioral model",
            f"    V(output_p, output_n) <+ pow(10, gain_db/20) * V(input_p, input_n);",
            "    ",
            "    // Power consumption",
            f"    I(vdd, vss) <+ power_w / V(vdd, vss);",
            "    ",
            "    // Input impedance",
            "    I(input_p, input_n) <+ V(input_p, input_n) / 50.0;",
            "  end",
            "",
            "endmodule"
        ])
        
        return '\n'.join(lines)
    
    def _generate_ads_code(self, circuit_result) -> str:
        """Generate Keysight ADS netlist code."""
        lines = [
            "# Generated by GenRF CircuitDiffuser",
            f"# Circuit: {circuit_result.topology}",
            f"# Technology: {circuit_result.technology}",
            f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            f".subckt {circuit_result.topology.lower()} input output vdd vss",
            ""
        ]
        
        # Add components in ADS format
        component_nodes = {}
        node_counter = 1
        
        for param_name, param_value in circuit_result.parameters.items():
            comp_name = param_name.split('_')[0]
            
            if '_w' in param_name:
                # MOSFET
                length_param = param_name.replace('_w', '_l')
                length = circuit_result.parameters.get(length_param, 100e-9)
                
                # Assign nodes
                if comp_name not in component_nodes:
                    component_nodes[comp_name] = {
                        'drain': f'n{node_counter}',
                        'gate': f'n{node_counter+1}',
                        'source': f'n{node_counter+2}',
                        'bulk': 'vss'
                    }
                    node_counter += 3
                
                nodes = component_nodes[comp_name]
                lines.append(f"{comp_name} {nodes['drain']} {nodes['gate']} {nodes['source']} {nodes['bulk']} "
                           f"NMOS W={param_value*1e6:.3f}um L={length*1e6:.3f}um")
            
            elif '_r' in param_name:
                # Resistor
                if comp_name not in component_nodes:
                    component_nodes[comp_name] = {
                        'p': f'n{node_counter}',
                        'n': f'n{node_counter+1}'
                    }
                    node_counter += 2
                
                nodes = component_nodes[comp_name]
                lines.append(f"{comp_name} {nodes['p']} {nodes['n']} R={param_value:.3e}")
            
            elif '_c' in param_name:
                # Capacitor
                if comp_name not in component_nodes:
                    component_nodes[comp_name] = {
                        'p': f'n{node_counter}',
                        'n': f'n{node_counter+1}'
                    }
                    node_counter += 2
                
                nodes = component_nodes[comp_name]
                lines.append(f"{comp_name} {nodes['p']} {nodes['n']} C={param_value:.3e}")
            
            elif '_l' in param_name and '_l' not in param_name.replace('_l', '_w'):
                # Inductor (only if not part of transistor length)
                if comp_name not in component_nodes:
                    component_nodes[comp_name] = {
                        'p': f'n{node_counter}',
                        'n': f'n{node_counter+1}'
                    }
                    node_counter += 2
                
                nodes = component_nodes[comp_name]
                lines.append(f"{comp_name} {nodes['p']} {nodes['n']} L={param_value:.3e}")
        
        lines.extend([
            "",
            ".ends",
            "",
            "# Performance summary:",
            f"# Gain: {circuit_result.performance.get('gain_db', 0):.2f} dB",
            f"# Noise Figure: {circuit_result.performance.get('noise_figure_db', 3):.2f} dB",
            f"# Power: {circuit_result.performance.get('power_w', 0.01)*1000:.2f} mW",
            ""
        ])
        
        return '\n'.join(lines)
    
    def export_matlab_function(self, circuit_result, filepath: Union[str, Path]) -> None:
        """Export circuit as MATLAB function for analysis."""
        filepath = Path(filepath)
        
        lines = [
            f"function [gain, nf, power] = {circuit_result.topology.lower()}_model(freq, params)",
            "% Generated by GenRF CircuitDiffuser",
            f"% Circuit: {circuit_result.topology}",
            f"% Technology: {circuit_result.technology}",
            f"% Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "%",
            "% Inputs:",
            "%   freq - Frequency vector (Hz)",
            "%   params - Structure with circuit parameters",
            "% Outputs:",
            "%   gain - Gain in dB",
            "%   nf - Noise figure in dB", 
            "%   power - Power consumption in W",
            "",
            "% Default parameters if not provided",
            "if nargin < 2"
        ]
        
        # Add default parameters
        lines.append("    params = struct();")
        for param_name, param_value in circuit_result.parameters.items():
            lines.append(f"    params.{param_name} = {param_value:.3e};")
        
        lines.extend([
            "end",
            "",
            "% Frequency-dependent model (simplified)",
            f"gain_dc = {circuit_result.performance.get('gain_db', 15):.2f};",
            f"nf_dc = {circuit_result.performance.get('noise_figure_db', 2):.2f};",
            f"power = {circuit_result.performance.get('power_w', 0.01):.3e};",
            "",
            "% Frequency response (first-order approximation)",
            "f_3db = 1e9; % 1 GHz bandwidth assumption",
            "s = 1j * 2 * pi * freq;",
            "H = gain_dc ./ (1 + s / (2*pi*f_3db));",
            "gain = 20 * log10(abs(H));",
            "",
            "% Noise figure (frequency independent for simplicity)",
            "nf = repmat(nf_dc, size(freq));",
            "",
            "end"
        ])
        
        with open(filepath, 'w') as f:
            f.write('\n'.join(lines))
        
        logger.info(f"Exported MATLAB function to {filepath}")
    
    def export_python_class(self, circuit_result, filepath: Union[str, Path]) -> None:
        """Export circuit as Python class for analysis."""
        filepath = Path(filepath)
        
        lines = [
            "# Generated by GenRF CircuitDiffuser",
            f"# Circuit: {circuit_result.topology}",
            f"# Technology: {circuit_result.technology}",
            f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "import numpy as np",
            "from typing import Dict, Union, Tuple",
            "",
            f"class {circuit_result.topology}Model:",
            '    """',
            f"    Behavioral model for {circuit_result.topology} circuit.",
            "    Generated automatically by GenRF CircuitDiffuser.",
            '    """',
            "",
            "    def __init__(self):",
            '        """Initialize circuit model with default parameters."""',
            "        self.parameters = {"
        ]
        
        # Add parameters
        for param_name, param_value in circuit_result.parameters.items():
            lines.append(f"            '{param_name}': {param_value:.3e},")
        
        lines.extend([
            "        }",
            "",
            "        self.performance = {",
            f"            'gain_db': {circuit_result.performance.get('gain_db', 15):.2f},",
            f"            'nf_db': {circuit_result.performance.get('noise_figure_db', 2):.2f},",
            f"            'power_w': {circuit_result.performance.get('power_w', 0.01):.3e},",
            f"            's11_db': {circuit_result.performance.get('s11_db', -15):.2f}",
            "        }",
            "",
            "    def frequency_response(",
            "        self, ", 
            "        freq: Union[float, np.ndarray],",
            "        temperature: float = 27.0",
            "    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:",
            '        """',
            "        Calculate frequency response.",
            "        ",
            "        Args:",
            "            freq: Frequency in Hz (scalar or array)",
            "            temperature: Temperature in Celsius",
            "            ",
            "        Returns:",
            "            Tuple of (gain_db, phase_deg, group_delay_s)",
            '        """',
            "        freq = np.atleast_1d(freq)",
            "        ",
            "        # Simplified frequency response model",
            f"        gain_dc = self.performance['gain_db']",
            "        f_3db = 1e9  # 1 GHz bandwidth assumption",
            "        ",
            "        # First-order low-pass response",
            "        s = 1j * 2 * np.pi * freq",
            "        H = 10**(gain_dc/20) / (1 + s / (2*np.pi*f_3db))",
            "        ",
            "        gain_db = 20 * np.log10(np.abs(H))",
            "        phase_deg = np.angle(H) * 180 / np.pi",
            "        group_delay_s = np.ones_like(freq) / (2*np.pi*f_3db)",
            "        ",
            "        return gain_db, phase_deg, group_delay_s",
            "",
            "    def noise_figure(self, freq: Union[float, np.ndarray]) -> np.ndarray:",
            '        """Calculate noise figure vs frequency."""',
            "        freq = np.atleast_1d(freq)",
            f"        return np.full_like(freq, self.performance['nf_db'])",
            "",
            "    def power_consumption(self, supply_voltage: float = 1.2) -> float:",
            '        """Calculate total power consumption."""',
            f"        return self.performance['power_w']",
            "",
            "    def s_parameters(",
            "        self,",
            "        freq: Union[float, np.ndarray],", 
            "        z0: float = 50.0",
            "    ) -> Dict[str, np.ndarray]:",
            '        """Calculate S-parameters."""',
            "        freq = np.atleast_1d(freq)",
            "        ",
            "        gain_db, _, _ = self.frequency_response(freq)",
            f"        s11_db = self.performance['s11_db']",
            "        ",
            "        return {",
            "            's11_db': np.full_like(freq, s11_db),",
            "            's21_db': gain_db,",
            "            's12_db': np.full_like(freq, -40.0),  # Isolation",
            "            's22_db': np.full_like(freq, -12.0)   # Output match",
            "        }",
            "",
            "    def update_parameters(self, new_params: Dict[str, float]):",
            '        """Update circuit parameters."""',
            "        self.parameters.update(new_params)",
            "        # Note: In a real implementation, performance would be recalculated",
            "",
            f"# Example usage:",
            "# circuit = {circuit_result.topology}Model()",
            "# freq = np.logspace(8, 11, 100)  # 100 MHz to 100 GHz", 
            "# gain, phase, gd = circuit.frequency_response(freq)",
            "# s_params = circuit.s_parameters(freq)"
        ])
        
        with open(filepath, 'w') as f:
            f.write('\n'.join(lines))
        
        logger.info(f"Exported Python class to {filepath}")
    
    def export_all_formats(self, circuit_result, output_dir: Union[str, Path]) -> Dict[str, Path]:
        """Export circuit to all supported formats."""
        output_dir = Path(output_dir)
        output_dir.mkdir(exist_ok=True, parents=True)
        
        exported_files = {}
        base_name = f"{circuit_result.topology.lower()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        try:
            # SKILL export
            skill_file = output_dir / f"{base_name}.il"
            self.export_skill(circuit_result, skill_file)
            exported_files['skill'] = skill_file
        except Exception as e:
            logger.warning(f"Failed to export SKILL: {e}")
        
        try:
            # Verilog-A export
            va_file = output_dir / f"{base_name}.va"
            self.export_verilog_a(circuit_result, va_file)
            exported_files['verilog_a'] = va_file
        except Exception as e:
            logger.warning(f"Failed to export Verilog-A: {e}")
        
        try:
            # ADS export
            ads_file = output_dir / f"{base_name}.net"
            self.export_ads(circuit_result, ads_file)
            exported_files['ads'] = ads_file
        except Exception as e:
            logger.warning(f"Failed to export ADS: {e}")
        
        try:
            # SPICE export
            spice_file = output_dir / f"{base_name}.cir"
            self.export_spice(circuit_result, spice_file)
            exported_files['spice'] = spice_file
        except Exception as e:
            logger.warning(f"Failed to export SPICE: {e}")
        
        try:
            # JSON export
            json_file = output_dir / f"{base_name}.json"
            self.export_json(circuit_result, json_file)
            exported_files['json'] = json_file
        except Exception as e:
            logger.warning(f"Failed to export JSON: {e}")
        
        try:
            # MATLAB export
            matlab_file = output_dir / f"{base_name}.m"
            self.export_matlab_function(circuit_result, matlab_file)
            exported_files['matlab'] = matlab_file
        except Exception as e:
            logger.warning(f"Failed to export MATLAB: {e}")
        
        try:
            # Python export
            python_file = output_dir / f"{base_name}.py"
            self.export_python_class(circuit_result, python_file)
            exported_files['python'] = python_file
        except Exception as e:
            logger.warning(f"Failed to export Python: {e}")
        
        logger.info(f"Exported {len(exported_files)} formats to {output_dir}")
        return exported_files